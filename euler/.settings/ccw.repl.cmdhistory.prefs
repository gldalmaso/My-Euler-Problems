#Sat Jan 14 23:21:05 BRST 2012
cmdhistory=["(reduce + (range 1 10))" "(reduce + (range 1 11))" "(reduce + (range 1 12))" "(reduce + (range 1 13))" "(reduce + (range 1 14))" "(doc reduce\\n     )" "(src reduce)" "(range 1 11)" "(doc loop)" "(+ 1 2)" "(doc reduce)" "(defn loop-inc (loop [n n] (if (\= n 0) (print n) (recur (dec n))))" "(defn loop-inc (loop [n n] (if (\= n 0) (print n) (recur (dec n)))))" "(defn loop-inc [n] (loop [n n] (if (\= n 0) (print n) (recur (dec n)))))" "(loop-inc 10)" "(defn loop-inc [n] (loop [n n] (print n) (if (\= n 0) (print n) (recur (dec n)))))" "(loop-inc 10)\\n" "(defn fibonacci-inc [[a b]] [b (+ a b)])" "(fibonacci-inc [0 1])" "(fibonacci-inc [1 2])" "(fibonacci-inc [3 4])" "(fibonacci-inc [1 2])" "((fn [[a b]] [b (+ a b)]) [0 1])" "((fn [x] (repeat x)) 10)" "((fn [x] (print x)) 10)" "(defn fibonnaci [n] \\n  (reduce\\n    (fn [[a b] _] (b (+ a b)))\\n    [1 2]\\n    (range 10))\\n  )" "(fibonnaci 10)" "(defn fibonacci [n] \\n  (reduce\\n    (fn [[a b] _] (b (+ a b)))\\n    [1 2]\\n    (range n))\\n  )" "(fibonacci 10)" "(defn fibonacci [n] \\n  (reduce\\n    (fn [[a b] _] [b (+ a b)])\\n    [1 2]\\n    (range n))\\n  )" "(fibonacci 10)\\n" "(defn fibonacci [n] \\n  (reduce\\n    (fn [[a b] _] [b (+ a b)])\\n    [0 1]\\n    (range n))\\n  )" "(fibonacci 10)\\n" "(defn fibonacci [n] \\n  (reduce\\n    (fn [[a b]] [b (+ a b)])\\n    [1 2]\\n    (range n))\\n  )" "(fibonacci 10)\\n" "(defn fibonacci [n] \\n  (reduce\\n    (fn [[a b] _] (conj [a b] '(+ a b)))\\n    [0 1]\\n    (range n))\\n  )" "(fibonacci 10)\\n" "(doc conj)" "(defn fibonacci [n] \\n  (reduce\\n    (fn [[a b] _] (conj [a b] (+ a b)))\\n    [0 1]\\n    (range n))\\n  )" "(fibonacci 10)\\n" "(defn fibonacci [n] \\n  (reduce\\n    (fn [[a b] _] (vector (conj [a b] (+ a b))))\\n    [0 1]\\n    (range n))\\n  )" "(fibonacci 10)\\n" "(defn fibonacci [n] \\n  (reduce\\n    (fn [x _] (conj x (+ (last x) _)))\\n    [0 1]\\n    (range n))\\n  )" "(fibonacci 10)\\n" "(defn fibonacci [n] \\n  (reduce\\n    (fn [x _] (conj x (+ (last x) _)))\\n    [1 2]\\n    (range n))\\n  )" "(fibonacci 10)\\n" "(defn fibonacci [n] \\n  (reduce\\n    (fn [x _] (conj x (apply + (take 2 x))))\\n    [1 2]\\n    (range n))\\n  )" "(fibonacci 10)\\n" "(conj [1 2] (apply + (take 2 [1 2])))" "(conj [2 3] (apply + (take 2 [2 3])))" "(conj [1 2 3] (apply + (take 2 [1 2 3])))" "(defn fibonacci [n] \\n  (reduce\\n    (fn [x _] (conj x (apply + (drop (- (count x) 2) x))))\\n    [1 2]\\n    (range n))\\n  )" "(fibonacci 10)\\n" "(defn fibonacci [n] \\n  (reduce\\n    (fn [x _] (conj x (apply + (drop (- (count x) 2) x))))\\n    [0 1]\\n    (range n))\\n  )" "(fibonacci 10)\\n" "(defn fibonacci [n] \\n  (reduce\\n    (fn [x _] (conj x (apply + (drop (- (count x) 2) x))))\\n    [1 2]\\n    (range (- n 2)))\\n  )" "(fibonacci 10)\\n" "(defn fibonacci [n]\\n  (filter\\n    even?\\n\\t  (reduce\\n\\t    (fn [x _] (conj x (apply + (drop (- (count x) 2) x))))\\n\\t    [1 2]\\n\\t    (range (- n 2)))\\n\\t  )\\n  )" "(fibonacci 10)\\n" "(defn fibonacci [n]\\n  (apply\\n    +\\n\\t  (filter\\n\\t    even?\\n\\t\\t  (reduce\\n\\t\\t    (fn [x _] (conj x (apply + (drop (- (count x) 2) x))))\\n\\t\\t    [1 2]\\n\\t\\t    (range (- n 2)))\\n\\t\\t  )\\n\\t  )\\n  )" "(fibonacci 10)\\n" "(defn fibonacci-roof [n]\\n  ((fn [a n] (loop [a a n n]\\n             let [b (apply + (drop (- (count a) 2) a))]\\n             (if (> b n)\\n               a\\n               (recur (conj a b) n)))) \\n    [1 2]))" "(defn fibonacci-roof [n]\\n  ((fn [a n] (loop [a a n n]\\n             (let [b (apply + (drop (- (count a) 2) a))]\\n\\t             (if (> b n)\\n\\t               a\\n\\t               (recur (conj a b) n))))) \\n    [1 2]))" "(fibonacci-roof 100)" "(defn fibonacci-roof [n]\\n  ((fn [a n] (loop [a a n n]\\n             (let [b (apply + (drop (- (count a) 2) a))]\\n\\t             (if (> b n)\\n\\t               a\\n\\t               (recur (conj a b) n))))) \\n    [1 2] n))" "(fibonacci-roof 100)\\n" "(fibonacci-roof 88)\\n" "(fibonacci-roof 188)\\n" "(fibonacci-roof 1880)\\n" "(defn fibonacci [n]\\n  (apply\\n    +\\n\\t  (filter\\n\\t    even?\\n\\t\\t  (fibonacci-roof n)\\n\\t\\t  )\\n\\t  )\\n  )" "(fibonacci 5)" "(fibonacci 1000)" "(fibonacci 4000000)" "(time (fibonacci 4000000))" "(time (fibonacci 4000000000N))" "(defn divisible-by [x y] (\= 0 (mod x y)))" "(divisible-by 10 5)" "(divisible-by 10 6)" "(divisible-by 10 6(defn factorize [x]\\n  (filter\\n    (fn [y] (divisible-by x y))\\n    (range 2 x))))" "(defn factorize [x]\\n  (filter\\n    (fn [y] (divisible-by x y))\\n    (range 2 x)))" "(factorize 13195)" "(map factorize (factorize 13195))" "(use euler.clojure.problem3)" "(use 'euler.clojure.problem3)" "(divisible-by 10 5)" "(map factorize (factorize 13195))" "(factorize (13195))" "(factorize 13195)" "(factorize 5)" "(prime? 5)" "(use 'euler.clojure.problem3)" "(prime? 5)\\n" "(prime? 6)\\n" "(prime? 1)\\n" "(map factorize (factorize 13195))" "(set (map factorize (factorize 13195)))" "(set (map (fn [x] (set factorize x)) (set (factorize 13195))))" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)" "(defn prime-factorize [n]\\n  (reduce\\n    (fn [x y] (clojure.set/union x (set (factorize y))))\\n    (factorize n)))" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)" "(type prime-factorize)" "(type prime?)" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)" "(reduce (fn [x y] (clojure.set/union x (set (factorize y)))) (factorize 13195))" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)" "(require [clojure.set])" "(require 'clojure.set)" "(reduce (fn [x y] (clojure.set/union x (set (factorize y)))) (factorize 13195))" "(prime-factorize 13195N)" "(conj (set 1) (set 2))" "(clojure.set/union (set 1) (set 2))" "(clojure.set/union \#{1} \#{2})" "(set (factorize 13195))" "(clojure.set/union (set (factorize 13195) (set '(2)))" "(clojure.set/union (set (factorize 13195) (set '(2))))" "(clojure.set/union (set (factorize 13195)) (set '(2)))" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)" "(prime-factorize 5)" "(prime-factorize 10)" "(use 'euler.clojure.problem3)" "(prime-factorize 10)" "(fn [x y] (clojure.set/union (set 2) (set (factorize 13195))))" "((fn [x y] (clojure.set/union (set x) (set (factorize y)))) 2 13195)" "((fn [x y] (clojure.set/union (set x) (set (factorize y)))) 5 7)" "(use 'euler.clojure.problem3)" "(prime-factorize 10)" "(set (factorize 10))" "(clojure.set/union 2 (set (factorize 5)))" "(set (factorize 5))" "(clojure.set/union 2 (set \#{}))" "(set \#{})" "(clojure.set/union (set 2) (set \#{}))" "(clojure.set/union \#{2} (set \#{}))" "(clojure.set/union (set '2) (set \#{}))" "(clojure.set/union (set (list 2)) (set \#{}))" "(use 'euler.clojure.problem3)" "(prime-factorize 10)" "(use 'euler.clojure.problem3)" "(prime-factorize 10)" "(prime-factorize 13195)" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)" "(prime-factorize 10)" "(use 'euler.clojure.problem3)" "(prime-factorize 10)" "(prime-factorize 100)" "(prime-factorize 1000)" "(prime-factorize 13195)" "(set (factorize 13195))" "(prime-factorize 13195)" "(map prime-factorize (prime-facotize 13195))" "(map prime-factorize (prime-factorize 13195))" "(apply prime-factorize (prime-factorize 13195))" "(factorize 5)" "(use 'euler.clojure.problem3)" "(factorize 5)" "(factorize 1)" "(prime-factorize 13195)\\n" "(use 'euler.clojure.problem3)" "(prime? 5)" "(use 'euler.clojure.problem3)" "(prime? 5)" "(prime? 6)" "(prime? 29)" "(time (prime? 29))" "(factorize 13195)" "(factorize 2639)" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)\\n" "(use 'euler.clojure.problem3)" "(prime-factorize 13195)\\n" "(filter prime? (set (factorize 13195)))" "(filter prime? (set (factorize 600851475143)))" "(use 'euler.clojure.problem3)" "(sqrt 16)" "(use 'euler.clojure.problem3)" "(sqrt 16)" "(use 'euler.clojure.problem3)" "(exact-integer-sqrt 16)" "(use 'euler.clojure.problem3)" "(defn find-divisible [n] (filter \#(\= 0 (mod n %)) (range n)))" "(find-divisible 10)" "(defn find-divisible [n] (filter \#(\= 0 (mod n %)) (range 1 n)))" "(find-divisible 10)" "(find-divisible 13195)" "(find-divisible 5)" "(map find-divisible (find-divisible 13195))" "(defn find-divisible [n] (filter \#(\= 0 (mod n %)) (range 1 (inc n))))" "(find-divisible 5)" "(map find-divisible (find-divisible 13195))" "(map (into find-divisible) (find-divisible 13195))" "(map (into find-divisible \#{}) (find-divisible 13195))" "(defn find-divisible [n] (set (filter \#(\= 0 (mod n %)) (range 1 (inc n)))))" "(find-divisible 5)" "(map find-divisible (find-divisible 13195))" "(map (fn [x] (conj x (find-divisible x))) (find-divisible 13195))" "(map (fn [x] (conj x (find-divisible x))) (find-divisible 130))" "(map (fn [x] (conj x (find-divisible x))) (find-divisible 10))" "(find-divisible 10)" "(find-divisible 20)" "(conj (find-divisible 10) (find-divisible 20))" "(use 'clojure.set)" "(clojure.set/union (find-divisible 10) (find-divisible 20))" "(find-divisible 30)" "(find-divisible 13195)" "(map + (find-divisible 13195))" "(map inc (find-divisible 13195))" "(map find-divisible (find-divisible 13195))" "(def factors (find-divisible 13195))" "factors" "(map \#(clojure.set/union factors (find-divisible %)) factors)" "(reduce \#(clojure.set/union factors (find-divisible %)) factors)" "(reduce (fn [x y] (clojure.set/union x (find-divisible y))) factors)" "(reduce (fn [x y] (clojure.set/union x (find-divisible y))) 30)" "(reduce (fn [x y] (clojure.set/union x (find-divisible y))) '30)" "(reduce (fn [x y] (clojure.set/union x (find-divisible y))) factors)" "(clojure.set/union (find-divisible (nth 1 factors)) factors)" "(clojure.set/union factors factors)" "(clojure.set/union (find-divisible 1) factors)" "(clojure.set/union (find-divisible 65) factors)" "(clojure.set/union (find-divisible 35) factors)" "(clojure.set/union (find-divisible 1885) factors)" "(apply (fn [x y] (clojure.set/union x (find-divisible y))) factors)" "(apply inc factors)" "(reduce inc factors)" "(reduce + factors)" "(reduce find-divisible factors)" "(reduce (fn [x y] (clojure.set/union (set x) (find-divisible y))) factors)" "(reduce (fn [x y] (clojure.set/union x (find-divisible y))) factors)" "(reduce (fn [x y] (clojure.set/union x (find-divisible y))) \#{} factors)" "(defn prime? [n] (\= 1 (find-divisible (Math/sqrt n))))" "(filter prime? (reduce (fn [x y] (clojure.set/union x (find-divisible y))) \#{} factors))" "(find-divisible (Math/sqrt 16))" "(math/sqrt 16)" "(Math/sqrt 16)" "(find-divisible 4.0)" "(find-divisible (int 4.0))" "(defn find-divisible [n] (filter \#(\= 0 (mod (int n) %)) (range 1 (int n))))" "(find-divisible 4.0)" "(require 'euler.clojure.problem3)" "(find-divisible 4.0)" "(find-divisible 4)" "(require 'euler.clojure.problem3)" "(defn find-divisible [n] (set (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int n))))))" "(find-divisible 4.0)" "(prime? 5)" "(prime? 3)" "(find-divisible (Math/sqrt 16))" "(find-divisible (Math/sqrt 5))" "(find-divisible (Math/sqrt 3))" "(find-divisible (Math/sqrt 11))" "(range 11)" "(range 1 12)" "(/ 11 3)" "(find-divisible 11)" "(find-divisible (Math/sqrt 11))" "(defn find-divisible [n] (set (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int (Math/sqrt n)))))))" "(find-divisible 11)" "(find-divisible 17)" "(find-divisible 13195)" "(require 'euler.clojure.problem3)" "(prime? 11)" "(require 'euler.clojure.problem3)" "(prime? 11)" "(require 'euler.clojure.problem3)" "(prime? 11)" "((fn [n] (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int (Math/sqrt n)))))) 11)" "((fn [n] (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int (Math/sqrt n)))))) 15)" "((fn [n] (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int (Math/sqrt n)))))) 7)" "((\= 1 (count (fn [n] (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int (Math/sqrt n)))))) 7)))" "((\= 1 (count (fn [n] (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int (Math/sqrt n))))) 7))))" "((\= 1 (count ((fn [n] (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int (Math/sqrt n)))))) 7))))" "(require 'euler.clojure.problem3)" "(prime? 11)" "(\= 1 (count ((fn [n] (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int (Math/sqrt n)))))) 7)))" "(\= 1 (count ((fn [n] (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int (Math/sqrt n)))))) 11)))" "(prime? 11)" "(\= 1 (count (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int (Math/sqrt n)))))))" "(defn prime? [n] (\= 1 (count (filter \#(\= 0 (mod (int n) %)) (range 1 (inc (int (Math/sqrt n))))))))" "(prime? 11)" "(use 'euler.clojure.problem3)" "(prime? 7)" "(factorize 13195)" "(use 'euler.clojure.problem3)" "(factorize 13195)" "(use 'euler.clojure.problem3)" "(factorize 13195)" "(factorize 600851475143)" "(use 'euler.clojure.problem3)" "(factorize 600851475143)" "(max (factorize 13195))" "(apply max (factorize 13195))" "(use 'euler.clojure.problem3)" "(time (print (apply max (factorize 600851475143))))" "(use 'euler.clojure.problem3)" "(prime? 11)" "(prime? 12)" "(time (find-divisible 600851475143))" "(time (factorize 600851475143))" "(time (factorize 13195))" "(reduce (fn [x y] \\n                            (clojure.set/union x (find-divisible y))) \\n                          \#{} \\n                          (find-divisible 13195))" "(filter prime? \#{1 5 7})" "(time (factorize 13195))" "(time (apply max (factorize 13195)))" "(use 'euler.clojure.problem3)" "(time (apply max (factorize 13195)))" "(time (prime? 600851475143))" "(time (map prime? (range 600851475143)))" "(map prime? (range 600851475143))" "(use 'euler.clojure.problem3)" "(time (print (apply max (factorize 600851475143))))" "(use 'euler.clojure.problem3)" "(find-divisible 600851475143)" "(find-divisible 600851475143 (Math/sqrt 600851475143))" "(filter prime? (find-divisible 600851475143 (Math/sqrt 600851475143)))" "(apply max (filter prime? (find-divisible 600851475143 (Math/sqrt 600851475143))))" "(time (apply max (filter prime? (find-divisible 600851475143 (Math/sqrt 600851475143)))))"]
eclipse.preferences.version=1
